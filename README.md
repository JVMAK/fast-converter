# fast-converter

（测试用例很全面）

3.0版的fast-converter和之前的版本有较大的区别，不兼容！不兼容！不兼容！

# fast-converter的架构

稳定点：

- fast-converter需要具有递归的能力，因此fast-converter提供了net.noboard.fastconverter.handler.base包。

    fast-converter的递归能力并不是与生俱来的，或者说由特定的主类实现的，它的递归能力由base包中几个AbstractFilterBaseConverterHandler的实现类完成。

    例如，ArrayToArrayConverterHandler提供了数组递归的能力，MapToMapConverterHandler提供了Map递归的能力，这些转换器可以通过ConverterFilter的实现类聚合在一起，ArrayToArrayConverterHandler和MapToMapConverterHandler聚合在一起，就能同时提供对数组和Map的递归能力。CommonConverterFilter提供了一种对ConverterFilter的实现，它通过将多种具有递归能力的转换器聚合起来，对外提供一种普适性的递归能力。

变化点：

- 具体的数据转化由一众AbstractConverterHandler的实现类完成

# 各类必要性

## Converter接口的supports方法

supports方法具有存在必要性，否则ConverterFilter没有充分的手段对Converter进行筛选。supports方法的参数有三种可行的方案

    boolean supports(Class clazz)

    boolean supports(Object value)

    boolean supports(T value)

Class太狭窄，它会使得supports函数仅能从类型入手筛选被转换数据，而我想要的是，转换器可以根据具体的数据来工作。泛型则会导致ConverterFilter的实现必须使用try catch包裹supports方法，否则它会有抛出ClassCastException的危险。所以接收Object成为了比较合适的选择。

## BeanToMapConverterHandler

由于BeanToMapConverterHandler提供了@FieldConverter的解释器，这意味着，你可以通过该注解指定特定的Converter到域上，而这些Converter也可能在ConverterFilter中使用，我们将null也当成一种数据存在形式（这意味着你可以通过向ConverterFilter注册一个排位靠前的null值转换器而使得整个转换过程对null都有统一的处理方式，就像CommonConverterFilter所做的那样），使得普遍的Converter没有支持null值得必要（也就是说除了NullConverterHandler之外，其他的Converter其实并没有必要实现对null值的兼容，就像StringConverterHandler的supports函数一样，它并不支持null值）。

为了让不支持null值的Converter可以和@FieldConverter很好的配合，BeanToMapConverterHandler将自己对null值进行处理，以确保指定到域上的Converter不会因为域是一个null值而抛出异常。

具体的说，当BeanToMapConverterHandler处理一个通过@FieldConverter指定了特定转换器的域时，如果域的值为null，则BeanToMapConverterHandler将丢弃该域，在转换结果map中将不会出现与该域对应的key-value。